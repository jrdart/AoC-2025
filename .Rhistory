)
for (i in 1:num_elements){
connections[i,i] <- 1
}
for(connection_idx in 1:1000){
current_connection <- c(0,0)
curr_dist <- Inf
#go through all the rows finding the smallest distance
for (element_idx in 1:num_elements){
#for eligible connections (i.e. not itself or previous connections)
eligible_array <- input[-which(connections[element_idx,]==1),]
#if its the first loop use the min
dists <- check_dists(element_idx,eligible_array)
if (min(dists)<curr_dist){
curr_dist <- min(dists)
current_connection[1] <- element_idx
current_connection[2] <- eligible_array$element[which(dists==min(dists))]
#print(min(dists))
#otherwise check is the minimum smaller than the current saved one
#when you get to the end that's your best one
}
if (element_idx==num_elements){
connections[current_connection[1],current_connection[2]] <- 1
connections[current_connection[2],current_connection[1]] <- 1
#print it
#print(paste0("current connection ",connection_idx))
#print(current_connection)
#make little lists of which ones are now connected
if(connection_idx==1){
networks <- list(
current_connection
)
}
if(connection_idx>1){
#are either of the current connections in one of the networks?
el_1_networks <- sapply(networks, function(y) current_connection[1] %in% y)
el_2_networks <- sapply(networks, function(y) current_connection[2] %in% y)
#if element 1 in one and element 2 in none
if(sum(el_1_networks)==1 && sum(el_2_networks)==0){
networks[[which(el_1_networks)]] <-
c(networks[[which(el_1_networks)]],
current_connection[2])
}
#if element 2 in one and element 1 in none
if(sum(el_1_networks)==0 && sum(el_2_networks)==1){
networks[[which(el_2_networks)]] <-
c(networks[[which(el_2_networks)]],
current_connection[1])
}
#its breaking cause sometimes you join two networks together
#if theyre both in different ones
if(sum(el_1_networks)==1 && sum(el_2_networks)==1 && any(el_1_networks!=el_2_networks)){
networks[[which(el_1_networks)]] <-
c(networks[[which(el_1_networks)]],networks[[which(el_2_networks)]])
networks[[which(el_2_networks)]] <- NULL
}
#if so add the OTHER one to that one
#if not add a new network
if(!any(sapply(networks, function(y) current_connection %in% y))){
networks[[length(networks)+1]] <- current_connection
}
#if()
}
print(connection_idx/1000)
}
}
}
remove(list = ls())
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
#required libraries
library(dplyr)
library(stringr)
library(readr)
#load in data
filepath <- paste0(getwd(),"/","input.txt")
input <- read.csv(
filepath,
header=F)
colnames(input) <- c("X","Y","Z")
num_elements <- nrow(input)
input$element <- 1:num_elements
#create a function
check_dists <- function(element,input_array){
(input[element,1] - input_array[,1])^2 + (input[element,2] - input_array[,2])^2 + (input[element,3] - input_array[,3])^2
}
#check it works
check_dists(1,input[-2,])
connections <- array(
data=0,
dim=c(num_elements,num_elements)
)
for (i in 1:num_elements){
connections[i,i] <- 1
}
for(connection_idx in 1:1000){
current_connection <- c(0,0)
curr_dist <- Inf
#go through all the rows finding the smallest distance
for (element_idx in 1:num_elements){
#for eligible connections (i.e. not itself or previous connections)
eligible_array <- input[-which(connections[element_idx,]==1),]
#if its the first loop use the min
dists <- check_dists(element_idx,eligible_array)
if (min(dists)<curr_dist){
curr_dist <- min(dists)
current_connection[1] <- element_idx
current_connection[2] <- eligible_array$element[which(dists==min(dists))]
#print(min(dists))
#otherwise check is the minimum smaller than the current saved one
#when you get to the end that's your best one
}
if (element_idx==num_elements){
connections[current_connection[1],current_connection[2]] <- 1
connections[current_connection[2],current_connection[1]] <- 1
#print it
#print(paste0("current connection ",connection_idx))
#print(current_connection)
#make little lists of which ones are now connected
if(connection_idx==1){
networks <- list(
current_connection
)
}
if(connection_idx>1){
#are either of the current connections in one of the networks?
el_1_networks <- sapply(networks, function(y) current_connection[1] %in% y)
el_2_networks <- sapply(networks, function(y) current_connection[2] %in% y)
#if element 1 in one and element 2 in none
if(sum(el_1_networks)==1 && sum(el_2_networks)==0){
networks[[which(el_1_networks)]] <-
c(networks[[which(el_1_networks)]],
current_connection[2])
}
#if element 2 in one and element 1 in none
if(sum(el_1_networks)==0 && sum(el_2_networks)==1){
networks[[which(el_2_networks)]] <-
c(networks[[which(el_2_networks)]],
current_connection[1])
}
#its breaking cause sometimes you join two networks together
#if theyre both in different ones
if(sum(el_1_networks)==1 && sum(el_2_networks)==1 && any(el_1_networks!=el_2_networks)){
networks[[which(el_1_networks)]] <-
c(networks[[which(el_1_networks)]],networks[[which(el_2_networks)]])
networks[[which(el_2_networks)]] <- NULL
}
#if so add the OTHER one to that one
#if not add a new network
if(!any(sapply(networks, function(y) current_connection %in% y))){
networks[[length(networks)+1]] <- current_connection
}
#if()
}
if(connection_idx %% 100 ==0){
print(paste0(connection_idx/1000,"%"))
}
}
}
}
remove(list = ls())
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
#required libraries
library(dplyr)
library(stringr)
library(readr)
#load in data
filepath <- paste0(getwd(),"/","input.txt")
input <- read.csv(
filepath,
header=F)
colnames(input) <- c("X","Y","Z")
num_elements <- nrow(input)
input$element <- 1:num_elements
#create a function
check_dists <- function(element,input_array){
(input[element,1] - input_array[,1])^2 + (input[element,2] - input_array[,2])^2 + (input[element,3] - input_array[,3])^2
}
#check it works
check_dists(1,input[-2,])
connections <- array(
data=0,
dim=c(num_elements,num_elements)
)
for (i in 1:num_elements){
connections[i,i] <- 1
}
for(connection_idx in 1:1000){
current_connection <- c(0,0)
curr_dist <- Inf
#go through all the rows finding the smallest distance
for (element_idx in 1:num_elements){
#for eligible connections (i.e. not itself or previous connections)
eligible_array <- input[-which(connections[element_idx,]==1),]
#if its the first loop use the min
dists <- check_dists(element_idx,eligible_array)
if (min(dists)<curr_dist){
curr_dist <- min(dists)
current_connection[1] <- element_idx
current_connection[2] <- eligible_array$element[which(dists==min(dists))]
#print(min(dists))
#otherwise check is the minimum smaller than the current saved one
#when you get to the end that's your best one
}
if (element_idx==num_elements){
connections[current_connection[1],current_connection[2]] <- 1
connections[current_connection[2],current_connection[1]] <- 1
#print it
#print(paste0("current connection ",connection_idx))
#print(current_connection)
#make little lists of which ones are now connected
if(connection_idx==1){
networks <- list(
current_connection
)
}
if(connection_idx>1){
#are either of the current connections in one of the networks?
el_1_networks <- sapply(networks, function(y) current_connection[1] %in% y)
el_2_networks <- sapply(networks, function(y) current_connection[2] %in% y)
#if element 1 in one and element 2 in none
if(sum(el_1_networks)==1 && sum(el_2_networks)==0){
networks[[which(el_1_networks)]] <-
c(networks[[which(el_1_networks)]],
current_connection[2])
}
#if element 2 in one and element 1 in none
if(sum(el_1_networks)==0 && sum(el_2_networks)==1){
networks[[which(el_2_networks)]] <-
c(networks[[which(el_2_networks)]],
current_connection[1])
}
#its breaking cause sometimes you join two networks together
#if theyre both in different ones
if(sum(el_1_networks)==1 && sum(el_2_networks)==1 && any(el_1_networks!=el_2_networks)){
networks[[which(el_1_networks)]] <-
c(networks[[which(el_1_networks)]],networks[[which(el_2_networks)]])
networks[[which(el_2_networks)]] <- NULL
}
#if so add the OTHER one to that one
#if not add a new network
if(!any(sapply(networks, function(y) current_connection %in% y))){
networks[[length(networks)+1]] <- current_connection
}
#if()
}
if(connection_idx %% 100 ==0){
print(paste0(connection_idx/10,"%"))
}
}
}
}
remove(list = ls())
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
#required libraries
library(dplyr)
library(stringr)
library(readr)
#load in data
filepath <- paste0(getwd(),"/","input.txt")
input <- read.csv(
filepath,
header=F)
colnames(input) <- c("X","Y","Z")
num_elements <- nrow(input)
input$element <- 1:num_elements
#create a function
check_dists <- function(element,input_array){
(input[element,1] - input_array[,1])^2 + (input[element,2] - input_array[,2])^2 + (input[element,3] - input_array[,3])^2
}
#check it works
check_dists(1,input[-2,])
connections <- array(
data=0,
dim=c(num_elements,num_elements)
)
for (i in 1:num_elements){
connections[i,i] <- 1
}
for(connection_idx in 1:1000){
current_connection <- c(0,0)
curr_dist <- Inf
#go through all the rows finding the smallest distance
for (element_idx in 1:num_elements){
#for eligible connections (i.e. not itself or previous connections)
eligible_array <- input[-which(connections[element_idx,]==1),]
#if its the first loop use the min
dists <- check_dists(element_idx,eligible_array)
if (min(dists)<curr_dist){
curr_dist <- min(dists)
current_connection[1] <- element_idx
current_connection[2] <- eligible_array$element[which(dists==min(dists))]
#print(min(dists))
#otherwise check is the minimum smaller than the current saved one
#when you get to the end that's your best one
}
if (element_idx==num_elements){
connections[current_connection[1],current_connection[2]] <- 1
connections[current_connection[2],current_connection[1]] <- 1
#print it
#print(paste0("current connection ",connection_idx))
#print(current_connection)
#make little lists of which ones are now connected
if(connection_idx==1){
networks <- list(
current_connection
)
}
if(connection_idx>1){
#are either of the current connections in one of the networks?
el_1_networks <- sapply(networks, function(y) current_connection[1] %in% y)
el_2_networks <- sapply(networks, function(y) current_connection[2] %in% y)
#if element 1 in one and element 2 in none
if(sum(el_1_networks)==1 && sum(el_2_networks)==0){
networks[[which(el_1_networks)]] <-
c(networks[[which(el_1_networks)]],
current_connection[2])
}
#if element 2 in one and element 1 in none
if(sum(el_1_networks)==0 && sum(el_2_networks)==1){
networks[[which(el_2_networks)]] <-
c(networks[[which(el_2_networks)]],
current_connection[1])
}
#its breaking cause sometimes you join two networks together
#if theyre both in different ones
if(sum(el_1_networks)==1 && sum(el_2_networks)==1 && any(el_1_networks!=el_2_networks)){
networks[[which(el_1_networks)]] <-
c(networks[[which(el_1_networks)]],networks[[which(el_2_networks)]])
networks[[which(el_2_networks)]] <- NULL
}
#if so add the OTHER one to that one
#if not add a new network
if(!any(sapply(networks, function(y) current_connection %in% y))){
networks[[length(networks)+1]] <- current_connection
}
#if()
}
if(connection_idx %% 10 ==0){
print(paste0(connection_idx/10,"%"))
}
}
}
}
network_sizes <- sapply(networks,length)
network_sizes <- network_sizes[order(network_sizes,decreasing=T)]
prod(network_sizes[1:3])
remove(list = ls())
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
#required libraries
library(dplyr)
library(stringr)
library(readr)
#load in data
filepath <- paste0(getwd(),"/","input.txt")
input <- read.csv(
filepath,
header=F)
colnames(input) <- c("X","Y","Z")
num_elements <- nrow(input)
input$element <- 1:num_elements
#create a function
check_dists <- function(element,input_array){
(input[element,1] - input_array[,1])^2 + (input[element,2] - input_array[,2])^2 + (input[element,3] - input_array[,3])^2
}
#check it works
check_dists(1,input[-2,])
connections <- array(
data=0,
dim=c(num_elements,num_elements)
)
for (i in 1:num_elements){
connections[i,i] <- 1
}
connection_idx <- 1
repeat{
current_connection <- c(0,0)
curr_dist <- Inf
#go through all the rows finding the smallest distance
for (element_idx in 1:num_elements){
#for eligible connections (i.e. not itself or previous connections)
eligible_array <- input[-which(connections[element_idx,]==1),]
#if its the first loop use the min
dists <- check_dists(element_idx,eligible_array)
if (min(dists)<curr_dist){
curr_dist <- min(dists)
current_connection[1] <- element_idx
current_connection[2] <- eligible_array$element[which(dists==min(dists))]
#print(min(dists))
#otherwise check is the minimum smaller than the current saved one
#when you get to the end that's your best one
}
if (element_idx==num_elements){
connections[current_connection[1],current_connection[2]] <- 1
connections[current_connection[2],current_connection[1]] <- 1
#print it
#print(paste0("current connection ",connection_idx))
#print(current_connection)
#make little lists of which ones are now connected
if(connection_idx==1){
networks <- list(
current_connection
)
connection_idx <- 2
}
if(connection_idx>1){
#are either of the current connections in one of the networks?
el_1_networks <- sapply(networks, function(y) current_connection[1] %in% y)
el_2_networks <- sapply(networks, function(y) current_connection[2] %in% y)
#if element 1 in one and element 2 in none
if(sum(el_1_networks)==1 && sum(el_2_networks)==0){
networks[[which(el_1_networks)]] <-
c(networks[[which(el_1_networks)]],
current_connection[2])
}
#if element 2 in one and element 1 in none
if(sum(el_1_networks)==0 && sum(el_2_networks)==1){
networks[[which(el_2_networks)]] <-
c(networks[[which(el_2_networks)]],
current_connection[1])
}
#its breaking cause sometimes you join two networks together
#if theyre both in different ones
if(sum(el_1_networks)==1 && sum(el_2_networks)==1 && any(el_1_networks!=el_2_networks)){
networks[[which(el_1_networks)]] <-
c(networks[[which(el_1_networks)]],networks[[which(el_2_networks)]])
networks[[which(el_2_networks)]] <- NULL
}
#if so add the OTHER one to that one
#if not add a new network
if(!any(sapply(networks, function(y) current_connection %in% y))){
networks[[length(networks)+1]] <- current_connection
}
#if()
}
#print(connection_idx)
}
#
}
if(length(networks[[1]])==num_elements){
break
}
}
input$X[current_connection[1]]*input$X[current_connection[2]]
#network_sizes <- sapply(networks,length)
#network_sizes <- network_sizes[order(network_sizes,decreasing=T)]
#prod(network_sizes[1:3])
View(input)
View(networks)
input$X[current_connection[1]]
input$X[current_connection[2]]
input$X[current_connection[1]] * input$X[current_connection[2]]
98642*97498
input$X[current_connection[1]]
input$X[current_connection[2]]
input$X[current_connection[1]]*input$X[current_connection[2]]
a <- input$X[current_connection[1]]
b <- input$X[current_connection[2]]
a*b
typeof(a)
typeof(b)
a
b
a*b
as.numeric(a)*as.numeric(b)
as.numeric(input$X[current_connection[1]])*as.numeric(nput$X[current_connection[2]])
as.numeric(input$X[current_connection[1]])*as.numeric(input$X[current_connection[2]])
remove(list = ls())
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
#required libraries
library(dplyr)
library(stringr)
library(readr)
#load in data
filepath <- paste0(getwd(),"/","test.txt")
input <- read.csv(
filepath,
header=F)
remove(list = ls())
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
#required libraries
library(dplyr)
library(stringr)
library(readr)
#load in data
filepath <- paste0(getwd(),"/","input.txt")
input <- read.csv(
filepath,
header=F)
colnames(input) <- c("X","Y")
num_elements <- nrow(input)
biggest_rectangle_size <- 0
for (tile_idx in 1:2){
rectangle_tiles <- c(0,0)
rectangles <- (abs((input[tile_idx,1]-input[,1]))+1)*
((abs(input[tile_idx,2]-input[,2]))+1)
if(max(rectangles)>biggest_rectangle_size){
biggest_rectangle_size <- max(rectangles)
rectangle_tiles[1] <- tile_idx
rectangle_tiles[2] <- which(rectangles==max(rectangles))
}
}
#part 2
centre <- c(
round(mean(input[,1])),
round(mean(input[,2])))
transformed_input <- input
transformed_input[,1] <- transformed_input[,1]-min(transformed_input[,1])+1
transformed_input[,2] <- transformed_input[,2]-min(transformed_input[,2])+1
big_matrix <- array(
data=0,
dim=c(max(transformed_input[,2]),max(transformed_input[,1]))
)
